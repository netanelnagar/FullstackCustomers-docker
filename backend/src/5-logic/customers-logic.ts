import { OkPacket } from "mysql";
import dal from "../2-utils/dal";
import CustomerModel from "../4-models/customer-model";
import { ResourceNotFoundError, ValidationError } from "../4-models/errors-model";
import Sale from "../4-models/sale-model";




async function getAllCustomers(): Promise<CustomerModel[]> {

    const sql = `
        SELECT CUST_CODE as customerId,
        CUST_NAME as customerName,
        CUST_CITY as customerCity,
        WORKING_AREA as workingArea,
        CUST_COUNTRY as customerCountry,
        PHONE_NO as customerPhone,
        AGENT_CODE as agentCode FROM customer
    `;


    const customers = await dal.execute(sql)

    return customers;
}


async function getOneCustomer(id: string): Promise<CustomerModel> {

    const sql = `
        SELECT CUST_CODE as customerId,
        CUST_NAME as customerName,
        CUST_CITY as customerCity,
        WORKING_AREA as workingArea,
        CUST_COUNTRY as customerCountry,
        PHONE_NO as customerPhone,
        AGENT_CODE as agentCode FROM customer
        WHERE CUST_CODE = \'${id}\'
    `;


    const customers = await dal.execute(sql);

    //because sql return array (some time where exists more than 1 in database)
    const customer = customers[0];

    if (!customer) { throw new ResourceNotFoundError(id) }

    return customer;
}


async function addNewCustomer(customer: CustomerModel): Promise<CustomerModel | void> {

    const err = customer.Validation();

    if (err) { throw new ValidationError(err); }

    const sql = `
        INSERT INTO customer(CUST_CODE,CUST_NAME,CUST_CITY, WORKING_AREA, CUST_COUNTRY,PHONE_NO, AGENT_CODE) 
        VALUES(\'${customer.customerId}\',\'${customer.customerName}\',\'${customer.customerCity}\',
        \'${customer.workingArea}\',\'${customer.customerCountry}\',\'${customer.customerPhone}\',\'${customer.agentCode}\')
    `;


    const info: OkPacket = await dal.execute(sql);

    //if id generated by database we write it to return customer with id
    //but now we get id from request because that we don't return customer
    //and router return the customer and it same
    //customer.id = info.insertId;
    //return customer;

}

async function putNewCustomer(customer: CustomerModel): Promise<CustomerModel | void> {

    const err = customer.Validation();

    if (err) { throw new ValidationError(err); }

    const sql = `
        UPDATE customer SET
        CUST_NAME = \'${customer.customerName}\',
        CUST_CITY = \'${customer.customerCity}\',
        WORKING_AREA = \'${customer.workingArea}\',
        CUST_COUNTRY = \'${customer.customerCountry}\',
        PHONE_NO = \'${customer.customerPhone}\',
        AGENT_CODE = \'${customer.agentCode}\'
        WHERE CUST_CODE = \'${customer.customerId}\'
        
    `;


    const info: OkPacket = await dal.execute(sql);

    //if id generated by database we write it to return customer with id
    //but now we get id from request because that we don't return customer
    //and router return the customer and it same
    //customer.id = info.insertId;
    //return customer;

}



async function patchCustomer(customer: CustomerModel): Promise<number | void> {

    let sql = `
        UPDATE customer SET
    `;

    const keys = Object.keys(customer) as Array<keyof typeof customer>;

    let sqlColumn;

    console.log(keys)
    for (const key of keys) {
        switch (key) {
            case 'customerName':
                sqlColumn = 'CUST_NAME';
                break;
            case 'customerCity':
                sqlColumn = 'CUST_CITY';
                break;
            case 'workingArea':
                sqlColumn = 'WORKING_AREA';
                break;
            case 'customerCountry':
                sqlColumn = 'CUST_COUNTRY';
                break;
            case 'customerPhone':
                sqlColumn = 'PHONE_NO';
                break;
            case 'agentCode':
                sqlColumn = 'AGENT_CODE';
                break;
            default:
                break;
        }
        if (customer[key] && key !== 'customerId') {
            sql += `${sqlColumn} = \'${customer[key]}\', `;
        }
    }

    sql = sql.slice(0, -2)

    sql += ` WHERE CUST_CODE = \'${customer.customerId}\'`;


    const info: OkPacket = await dal.execute(sql);

}



async function deleteCustomer(id: string) {

    const sql = `DELETE FROM customer WHERE CUST_CODE = \'${id}\'`;

    console.log(sql);

    await dal.execute(sql);
}



async function updatePriceForProducts(year: string): Promise<void> {

    const sql = `UPDATE products SET list_price = list_price * 1.1 WHERE model_year = \'${year}\'`

    await dal.execute(sql);
}

async function addNewSale(sale: Sale): Promise<void> {

    const err = sale.validate();

    if (err) { throw new ValidationError(err); }

    const sql = `INSERT INTO 
    sales(TITLE_OF_SALE,START_DATE, END_DATE, PRODUCT_ID,DISCOUNT_PERCENT) 
    VALUES(\'${sale.titleOfSale}\',\'${sale.startDate}\',
    \'${sale.endDate}\',\'${sale.productId}\',\'${sale.discountPercent}\')
    `;

    // console.log(sql);

    try {
        const info = await dal.execute(sql);

        console.log(info)

    } catch (error) {
        let createTable = `CREATE TABLE sales (
            ID INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
            TITLE_OF_SALE varchar(255),
            START_DATE varchar(255),
            END_DATE varchar(255),
            DISCOUNT_PERCENT varchar(255),
            PRODUCT_ID INT,
            FOREIGN KEY (PRODUCT_ID) REFERENCES products(product_id)
        )`

        console.log(createTable)

        await dal.execute(createTable);

    }




}


export default {
    getAllCustomers,
    getOneCustomer,
    addNewCustomer,
    putNewCustomer,
    patchCustomer,
    deleteCustomer,
    updatePriceForProducts,
    addNewSale
}